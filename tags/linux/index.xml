<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Linux on A Traveller in Space and Time</title>
    <link>http://traveller42.github.io/tags/linux/</link>
    <description>Recent content in Linux on A Traveller in Space and Time</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>&amp;copy; 2016. All rights reserved.</copyright>
    <lastBuildDate>Sun, 10 Apr 2016 21:06:13 -0400</lastBuildDate>
    <atom:link href="http://traveller42.github.io/tags/linux/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Relative Performance</title>
      <link>http://traveller42.github.io/post/relative-performance/</link>
      <pubDate>Sun, 10 Apr 2016 21:06:13 -0400</pubDate>
      
      <guid>http://traveller42.github.io/post/relative-performance/</guid>
      <description>

&lt;p&gt;I&amp;rsquo;ve been quite impressed with the performance of the Chromebook that has
become my primary portable system.  It is an Acer Chromebook 11 C740.  The CPU
is a dual-core Celeron 3205U running at a nominal 1.5 GHz.  It has 4 GB of RAM
and a 256 GB SSD drive.  I&amp;rsquo;m running this system in Developer mode which gives
shell access.  I&amp;rsquo;ve created a chroot that is running a current version of
Ubuntu.  This is running within the ChromeOS system.  I decided to do some
testing to see what the real values were.  This is the &lt;strong&gt;new&lt;/strong&gt; system.&lt;/p&gt;

&lt;p&gt;The &lt;strong&gt;big&lt;/strong&gt; system was custom built a few years ago and has multiple spinning
disks, the smallest of which is 400 GB, and 16 GB of RAM.  The CPU is an
eight-core AMD FX-8120.&lt;/p&gt;

&lt;p&gt;The &lt;strong&gt;old&lt;/strong&gt; system is a Dell Insprion E1405 purchsed nearly 9 years ago.  The CPU
is a dual-core Core 2 Duo T7200 running at a nominal 2.0 GHz.  It has 3.2 GB of
RAM and a 320 GB spinning disk.  This has become my primary desktop as its
hinge has broken and it is no longer usable as a laptop.&lt;/p&gt;

&lt;h1 id=&#34;michi-go:6f0f4fc41711cf4e87e48dead024b7b0&#34;&gt;Michi-Go&lt;/h1&gt;

&lt;p&gt;The process that got my attention is a program I translated from Python to the
Go language that plays the Go game.  This program reads a couple of large files
once at the start, but is processor-bound for the rest of execution.&lt;/p&gt;

&lt;p&gt;There are a couple benchmark test built into the program.  The first,
mcbenchmark, reads the pattern files and then does 20 playouts of the initial,
empty, board.  This benchmark is single-threaded.  The second, tsbenchmark, starts
with the initial, empty, board and generates a move.  This requires 1400 playouts
in the current version of the program.  This benchmark is multi-threaded.&lt;/p&gt;

&lt;p&gt;The results for this set of test are:&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;System&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;mcbenchmark&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;tsbenchmark&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Old&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;7.689s&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;28,584s&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;New&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;7.452s&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;24.709s&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Big&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;4.966s&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;8.802s&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;There is some indication that the Chromebook, new system, may be faster per thread
in the &lt;strong&gt;tsbenchmark&lt;/strong&gt; than the big system.  I&amp;rsquo;ll need to look at this in more
detail.&lt;/p&gt;

&lt;h1 id=&#34;unix-bench:6f0f4fc41711cf4e87e48dead024b7b0&#34;&gt;Unix Bench&lt;/h1&gt;

&lt;p&gt;This is an old series of benchmarks used to evaluate the relative performance of
servers.  This is version 5.1.3 of the Byte Unix Benchmarks.  I&amp;rsquo;m only reporting
the overall score for each system.  The default is to do a single-threaded run
and a multi-threaded run with the number of parallel processes equal to the
number of cores available.&lt;/p&gt;

&lt;p&gt;These are the results:&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;System&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;1 thread&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;2 threads&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;8 threads&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Old&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;671.4&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1312.8&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;New&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;777.1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1495.0&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Big&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;832.6&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;-&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2169.1&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;I should probably try to fill in some of the gaps in this data to better
understand the differences in the operation of these three systems.&lt;/p&gt;

&lt;h1 id=&#34;conclusions:6f0f4fc41711cf4e87e48dead024b7b0&#34;&gt;Conclusions&lt;/h1&gt;

&lt;p&gt;Not too much to draw at present, but one thing is pretty clear:  The modern
Celeron is better than the old mobile Core 2 Duo, even at a slower clock speed.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>What Image to Start With</title>
      <link>http://traveller42.github.io/post/what-image-to-start-with/</link>
      <pubDate>Thu, 07 Apr 2016 21:38:03 -0400</pubDate>
      
      <guid>http://traveller42.github.io/post/what-image-to-start-with/</guid>
      <description>

&lt;h1 id=&#34;decisions-decisions-decisions:59d6925dffdfb128a2dff6cc70730079&#34;&gt;Decisions, Decisions, Decisions&lt;/h1&gt;

&lt;p&gt;Since a single system image OS is not a viable options, I need to decide what
system image to start with.&lt;/p&gt;

&lt;p&gt;As interesting as Plan 9 is, I think I will wait an look at that one after I
have more experience with the capabilities of the more travelled path.&lt;/p&gt;

&lt;p&gt;I will use a Linux load of some kind.  This environment is very efficient and I
am very familiar with building and maintaining system using Linux.  This
narrows the choice down to two main alternatives: Raspbian and Arch.&lt;/p&gt;

&lt;h1 id=&#34;raspbian:59d6925dffdfb128a2dff6cc70730079&#34;&gt;Raspbian&lt;/h1&gt;

&lt;p&gt;The most popular load of the Raspberry Pi series is Raspbian, a derivative of
the Debian Linux family.  This is not much of a surprise as Raspbian is
designed to support the primary goal of the Raspberry Pi program, education.
It is quite friendly in its implementation.  It presents a graphical desktop,
includes many applications in the base load, and uses the same Apt package
management tools as Ubuntu, another Debian derivative.  The current release
supports all variants of the Raspberry Pi from the original ARMv6 models to
the most recent ARMv8 model.  This consistency will simplify configuration
and could allow using some of the older devices I have with the nodes in the
cluster.  The current version of Raspbian is based on the Debian Jessie
release.  There is also a Raspbian Jessie Lite image that has only the base
OS and a minimal set of tools.  These can be used to the nodes other than the
head node.  (It can also be used for the head node once I know what I want
packages I want to use.)&lt;/p&gt;

&lt;h1 id=&#34;arch:59d6925dffdfb128a2dff6cc70730079&#34;&gt;Arch&lt;/h1&gt;

&lt;p&gt;Arch Linux on ARM (ALARM) is another option.  Arch uses a different image for
the original models of Raspberry Pi and the new models, 2 and 3.  This starts
as a minimal collection of tools expecting the user to install those items
needed for the task at hand.  This project requires more knowledge of Linux
than Raspbian which shouldn&amp;rsquo;t be a major issue for me.  It also uses a
different package management tool, pacman, that I do not have experience with.
There will be more building of tools from source, but that also allows more
control.  This may eventually lead to a better system and improved performance
relative to Raspbian.  It might be easier to adapt a 64-bit kernel using Arch
as a basis.&lt;/p&gt;

&lt;h1 id=&#34;current-plan:59d6925dffdfb128a2dff6cc70730079&#34;&gt;Current Plan&lt;/h1&gt;

&lt;p&gt;I&amp;rsquo;ve downloaded each of the images available.  I will create a boot image for
each and see what that looks like.  I will use that review to guide where I go
next.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>